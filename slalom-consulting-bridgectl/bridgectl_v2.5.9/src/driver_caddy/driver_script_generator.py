import pathlib
from dataclasses import dataclass
from pathlib import Path

import yaml

from src import download_util
from src.enums import LINUX_DISTROS
from src.lib.general_helper import StringUtils
from src.models import LoggerInterface, CONFIG_DIR
from src.driver_caddy.s3_client import S3Client


@dataclass
class DriverDef:
    driver: str
    os: str
    type: str
    download_url: str
    website: str = None
    version: str = None
    install: str = None
    test: str = None
    comment: str = None
    #FutureDev: add taco_file_url property, that will be downloaded and added to the ~/Documents/My_Tableau_Bridge_Repository$beta/Connectors dir.


class DriverScriptGenerator:
    def __init__(self, logger: LoggerInterface, buildimg_path: str):
        self.logger = logger
        self.db_aliases = {}
        self.drivers_def = []
        self.pre_post_scripts = []
        self.buildimg_path = Path(buildimg_path)
        self.buildimg_drivers_path: Path = self.buildimg_path / "drivers"
        self.driver_loader = DriverDefLoader(logger)

    def resolve_references(self):
        """ Check if additional drives need to be replaced by reference
            line format is: `ref: os_name/driver_version`
        """
        drivers_def = []
        self.drivers_def = []
        for d in drivers_def:
            if d.get('ref'):
                (add_drivers_fn, add_driver_version) = d.get('ref').split('/')
                with open(DriverDefLoader.driver_caddy_dir / f'drivers_{add_drivers_fn}.yaml', 'r') as f:
                    for a_d in yaml.safe_load(f):
                        if a_d['driver'] == add_driver_version:
                            self.drivers_def.append(a_d)
                            break
            else:
                self.drivers_def.append(d)
        pass

    def get_driver_definition(self, driver_name, linux_distro) -> DriverDef:
        for d in self.drivers_def:
            if d['driver'] == driver_name and linux_distro in str(d['os']):
                return DriverDef(**d)
        return None

    def get_pre_post_scripts(self, linux_distro: str):
        pre_download_script = None
        pre_install_script = None
        post_install_script = None
        for s in self.pre_post_scripts:
            if linux_distro in str(s.get('script_os')):
                pre_download_script = s.get('pre_download_script')
                pre_install_script = s.get('pre_install_script')
                post_install_script = s.get('post_install_script')
                break
        if not pre_download_script:
            raise Exception(f'No pre_download_script found for os={linux_distro}')
        if not pre_install_script:
            raise Exception(f'No pre_install_script found for os={linux_distro}')
        if not post_install_script:
            raise Exception(f'No post_install_script found for os={linux_distro}')
        return pre_download_script, pre_install_script, post_install_script

    def gen(self, driver_names: list, linux_distro, use_download_cache: bool):
        if not isinstance(driver_names, list):
            raise Exception(f"driver_names is not a list. value is {driver_names}")
        if linux_distro not in LINUX_DISTROS:
            raise Exception(f"Invalid linux_distro: {linux_distro} not in {LINUX_DISTROS}")

        # STEP - Prep
        self.pre_post_scripts, self.drivers_def = self.driver_loader.load_driver_defs()
        if not self.buildimg_drivers_path.exists():
            self.buildimg_drivers_path.mkdir()

        pre_download_script, pre_install_script, post_install_script = self.get_pre_post_scripts(linux_distro)

        # STEP - Generate driver scripts
        download_out = f"# Database driver download script for linux distro: {linux_distro}, generated by Driver Caddy\n"
        install_out = f"# Database driver install script for linux distro: {linux_distro}, generated by Driver Caddy\n"
        set_trace = "set -ex"
        download_out += f"# pre-download\n{set_trace}\n{pre_download_script}\n\n"
        install_out += f"# pre-install\n{set_trace}\n{pre_install_script}\n\n"
        copy_driver_files = []

        s3_client = S3Client()
        for driver_name in driver_names:
            driver_def = self.get_driver_definition(driver_name, linux_distro)
            if driver_def is None:
                self.logger.warning(f'No driver definition for driver={driver_name} and os={linux_distro}')
                continue
            # STEP -download script
            durl = str(driver_def.download_url).lstrip()
            driver_file_name = driver_def.download_url.split('/')[-1]
            dl_path = self.buildimg_drivers_path / driver_file_name
            download_out += f'# Driver {driver_name} downloaded from {durl}\n'
            if durl.startswith(DriverKeywords.LOCAL):
                driver_file_name = driver_def.download_url.replace(DriverKeywords.LOCAL, "").lstrip()
                dl_path = self.buildimg_drivers_path / driver_file_name
                error_msg = self.validate_local_driver(driver_def)
                if error_msg:
                    self.logger.warning(error_msg)
                    raise Exception(error_msg)
                else:
                    self.logger.info(f'Using cached driver: {dl_path}')
            elif durl.startswith(DriverKeywords.S3):
                if use_download_cache:
                    if not dl_path.exists():
                        self.logger.info(f'downloading driver from S3: {durl}')
                        s3_client.download_file(durl, self.buildimg_drivers_path) # if local file doesn't already exist, then download it from S3
                else:
                    #aws s3 cp s3://tableau-app-services-dev/ec2_image_builder/drivers_odbc/amazonhiveodbc_2.6.9.1009-2_amd64.deb ./driver_amazonhive.deb --no-progress
                    download_out += f"aws s3 cp {durl} /tmp/driver_caddy/ --no-progress\n"
            elif durl.startswith(DriverKeywords.http):
                if use_download_cache:
                    if not dl_path.exists():
                        self.logger.info(f'downloading driver from web: {durl} to {self.buildimg_drivers_path}')
                        download_util.download_file(durl, str(dl_path))
                    else:
                        # just show filename, not full path
                        self.logger.info(f'Using cached driver: {dl_path}')
                else:
                    download_out += f"curl -sS --location --output /tmp/driver_caddy/{driver_file_name} {driver_def.download_url}\n"
            else:
                prefixes = StringUtils.get_values_from_class(DriverKeywords)
                raise Exception(f"Invalid download_url in drivers.yaml `{durl}`, for driver `{driver_name}`. download_url should start with one of these: {','.join(prefixes)}")
            download_out += f"[ -f /tmp/driver_caddy/{driver_file_name} ] || exit 1" + "\n\n"
            copy_driver_files.append(driver_file_name)

            # STEP - install script
            v = driver_def.version if driver_def.version else ""
            install_out += f'# Install {driver_name}   {v}\n'
            if driver_def.type == DriverType.jar:
                install_out += f"mv -f /tmp/driver_caddy/{driver_file_name} /opt/tableau/tableau_driver/jdbc/{driver_file_name}\n\n"
            elif driver_def.type == DriverType.install:
                install_out += self.replace_variables(driver_def.install, {"$download_name": driver_file_name}) + "\n"
                # script_i += "# test\n" + driver_def['test']
            else:
                raise Exception(f"driver type {driver_def.type} not recognized")

        install_out += f'\n# post-install\n{post_install_script}\n'
        path_download_drivers, path_install_drivers = self.script_path_buildimg()
        with open(path_download_drivers, 'w', newline='\n') as file:
            file.write(download_out)
        with open(path_install_drivers, 'w', newline='\n') as file:
            file.write(install_out)

        return copy_driver_files

    def script_path_buildimg(self):
        path_download_drivers = self.buildimg_path / 'drivers_download.sh'
        path_install_drivers = self.buildimg_path / 'drivers_install.sh'
        return path_download_drivers, path_install_drivers

    @staticmethod
    def replace_variables(script, replacements):
        for var, replacement in replacements.items():
            script = script.replace(var, replacement)
        return script

    @staticmethod
    def change_download_urls_to_local(def_file: Path):
        """
        change download urls in drivers.yaml to just "LOCAL filename"
        """

        with open(def_file, 'r') as file:
            lines = file.readlines()

        with open(def_file, 'w') as file:
            for line in lines:
                if line.lstrip().startswith("download_url:"):
                    parts = line.strip().split('/')
                    filename = parts[-1]
                    file.write(f"  download_url: LOCAL {filename}\n")
                else:
                    file.write(line) # Write the line unmodified

    def validate_local_driver(self, driver_def: DriverDef) -> str:
        """
        Validates that a LOCAL driver file exists in the buildimg directory.
        Returns an error message if the file is missing, None if the file exists.
        """
        if not driver_def.download_url.startswith(DriverKeywords.LOCAL):
            return None
            
        driver_file_name = driver_def.download_url.replace(DriverKeywords.LOCAL, "").lstrip()
        dl_path = self.buildimg_drivers_path / driver_file_name
        
        if not dl_path.exists():
            website_info = f", you can download from website {driver_def.website}" if driver_def.website else ""
            return f'Local driver file for `{driver_def.driver}` not found at `{dl_path}`{website_info}'
            
        return None


class DriverDefLoader:
    def __init__(self, logger):
        self.logger = logger

    driver_caddy_dir = pathlib.Path(__file__).parent
    system_driver_def_path = pathlib.Path(__file__).parent / "drivers.yaml"
    user_drivers_def_path = CONFIG_DIR / "drivers.yaml"

    def validate_def_file(self):
        pre_post_scripts, drivers_def = self.load_driver_defs()
        if not drivers_def:
            return "No driver definitions found"
        for count, item in enumerate(drivers_def, 1):
            if 'driver' not in item:
                return f"driver name missing for item {count}"
            driver_name = item['driver']
            if 'os' not in item:
                return f"os name missing for {driver_name}"
            if 'type' not in item:
                return f"type missing for {driver_name}"
            if 'download_url' not in item:
                return f"download_url missing  for {driver_name}"
            if item['type'] == DriverType.install:
                if 'install' not in item:
                    return f"install script missing for driver {driver_name}"

        for count_s, script in enumerate(pre_post_scripts, 1):
            if 'script_os' not in script:
                return f"'script_os' missing for item {count_s}, content:{script}"
            script_os = script['script_os']
            if 'pre_download_script' not in script:
                return f"pre_download_script missing for {script_os}"
            if 'pre_install_script' not in script:
                return f"pre_install_script missing for {script_os}"
            if 'post_install_script' not in script:
                return f"post_install_script missing for {script_os}"

    @classmethod
    def get_active_path(cls):
        """
        Returns the path to the active driver definition file.
        """
        if cls.user_drivers_def_path.exists():
            p = cls.user_drivers_def_path
        else:
            p = cls.system_driver_def_path
        return p

    def load_driver_defs(self):
        p = self.get_active_path()
        if not p or not p.exists():
            self.logger.error(f"file {p} does not exist.")
            return None, None
        with open(p, 'r') as f:
            content = yaml.load_all(f, Loader=yaml.FullLoader)
            docs = list(content)
            if not len(docs) == 2:
                self.logger.error(f"invalid driver definition file format. Must have 2 documents. file: {p}")
                return None, None
            return docs[0], docs[1]

    def get_driver_names(self, linux_distro):
        pre, defs = self.load_driver_defs()
        if not defs:
            return []
        names = []
        for item in defs:
            if linux_distro in item['os']:
                names.append(item['driver'])
        return names


class DriverType:
    jar: str = "jar"
    install: str = "install"


class DriverKeywords:
    LOCAL: str = "LOCAL"
    S3: str = "s3://"
    http: str = "http"
